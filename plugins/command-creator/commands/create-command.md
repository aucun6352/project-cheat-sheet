# 커맨드 생성 커맨드 (Create Command)

이 커맨드는 Claude Code에서 사용할 수 있는 새로운 Slash 커맨드를 대화형으로 생성합니다.

## 목적

사용자와 대화형으로 상호작용하며 표준화된 구조의 Slash 커맨드 파일을 자동으로 생성합니다. 복잡한 파일 구조를 수동으로 만들지 않고도 일관된 품질의 커맨드를 빠르게 작성할 수 있습니다.

## Extended Thinking

당신은 Slash 커맨드 생성 전문가로서 다음과 같이 동작합니다:

**📋 진행 상황 체크리스트**:
- [ ] Phase 0: 대화 분석 및 워크플로우 추출 (조건부)
- [ ] Phase 1: 기본 메타데이터 수집 (이름, 설명)
- [ ] Phase 2: 워크플로우 정의 (Triggers, Flow, Boundaries)
- [ ] Phase 3: 도구 설정 (Tools)
- [ ] Phase 4: 예제 및 문서화 (Usage, Examples)
- [ ] Phase 5: 파일 생성 (템플릿 기반 생성)
- [ ] Phase 6: 검증 및 완료 (내용 검증, 사용자 안내)

**🔄 진행 방식**:
각 Phase를 시작할 때마다 다음과 같이 진행 상황을 안내합니다:
```
✅ Phase X 완료 → 🔄 Phase Y 시작: [Phase 설명]

📊 진행 상황: X/7 Phase 완료
```

**핵심 동작**:
1. **대화 내용 분석**: 현재 세션의 대화 히스토리를 분석하여 워크플로우, 자동화 프로세스, 실행 단계를 추출합니다
2. **지능형 추천**: 분석 결과를 바탕으로 커맨드 이름, 트리거, 실행 단계, 도구를 자동으로 제안합니다
3. **대화형 정보 수집**: AskUserQuestion 도구를 활용하여 추천된 내용을 제시하고 사용자가 선택/수정하도록 합니다
4. **입력 검증**: 사용자 입력이 유효한지 확인하고, 필요시 재질문합니다
5. **구조화된 생성**: 표준 Slash 커맨드 템플릿을 사용하여 일관된 구조를 유지합니다
6. **품질 보증**: 생성된 파일이 올바른 형식과 필수 섹션을 포함하는지 검증합니다
7. **친절한 안내**: 생성 완료 후 사용 방법을 명확히 안내합니다

## 실행 단계

### Phase 0: 대화 분석 및 워크플로우 추출 (조건부)

**⚠️ 중요**: 현재 세션의 대화 내용이 충분하지 않은 경우 이 단계를 건너뛰고 **Phase 1**로 직접 이동합니다.

**대화 내용 충분성 판단 기준**:
- 대화 메시지 수가 5개 미만인 경우 → Phase 0 건너뛰기
- 기술적 내용이나 워크플로우가 전혀 없는 경우 → Phase 0 건너뛰기
- 단순 인사나 질문만 있는 경우 → Phase 0 건너뛰기

**대화 내용이 충분한 경우에만 다음을 수행합니다:**

1. **대화 히스토리 분석**
   - 현재 세션에서 논의된 워크플로우와 자동화 프로세스 식별
   - 실행 단계와 절차 추출
   - 대화에서 언급된 도구와 명령어 수집
   - 자동화가 필요한 작업과 조건 파악

2. **커맨드 메타데이터 자동 생성**
   - **추천 커맨드 이름 (2-3개)**:
     - 워크플로우 기반으로 kebab-case 형식의 이름 제안
     - 예: "deploy-production", "run-tests", "code-review"

   - **자동 생성 설명**:
     - 워크플로우 내용을 1-2문장으로 요약
     - 커맨드의 목적과 실행 결과를 명확히 표현

   - **트리거 조건 추출**:
     - 대화에서 "~할 때", "~하면" 등의 조건 수집
     - 자동 실행 시나리오 파악

   - **실행 단계 정리** (Behavioral Flow):
     - 대화에서 논의된 단계별 작업 순서 구조화
     - 각 단계의 목적과 동작 명확화

   - **도구 사용 식별** (Tool Coordination):
     - 대화에서 언급된 Bash 명령, 파일 작업 등 수집
     - 필요한 도구 파악

   - **경계 조건 파악** (Boundaries):
     - 대화에서 "~해야 한다", "~하면 안 된다" 수집
     - Will/Will Not 조건 명확화

3. **분석 결과 요약**
   ```
   📊 대화 분석 완료!

   🔍 발견된 워크플로우:
   - 주요 작업: {식별된_워크플로우}
   - 실행 단계: {단계_수}단계
   - 사용 도구: {도구_목록}
   - 트리거 조건: {조건_수}개

   💡 이제 추천 내용을 바탕으로 커맨드를 생성합니다.
   ```

**대화 내용이 불충분한 경우 안내**:
   ```
   📊 대화 내용 분석 결과

   ℹ️ 현재 세션의 대화 내용이 부족하여 자동 추천이 어렵습니다.

   💡 직접 입력 모드로 진행합니다.
      - 모든 정보를 수동으로 입력해주세요
      - 또는 커맨드 주제에 대해 먼저 대화를 나눈 후 다시 시도해보세요
   ```

### Phase 1: 기본 메타데이터 수집

**Phase 0을 건너뛴 경우**: 추천 없이 직접 입력 받습니다.
**Phase 0을 완료한 경우**: 추천된 내용을 제시하고 사용자가 선택/수정하도록 합니다.

**질문 1 - 커맨드 이름 선택**

**A. Phase 0을 완료한 경우 (추천 모드)**:
```
질문: "대화 분석을 바탕으로 다음 커맨드 이름을 추천합니다. 선택하거나 직접 입력해주세요."
선택지:
  - 옵션 1: {추천_이름_1} (워크플로우: {관련_작업_1})
  - 옵션 2: {추천_이름_2} (워크플로우: {관련_작업_2})
  - 옵션 3: {추천_이름_3} (워크플로우: {관련_작업_3})
  - 옵션 4: 직접 입력하기
```

**B. Phase 0을 건너뛴 경우 (직접 입력 모드)**:
```
질문: "생성할 커맨드의 이름을 입력해주세요"
- 형식: kebab-case (소문자, 하이픈만 사용)
- 예: deploy-production, run-tests, code-review
- 검증: 형식이 올바르지 않으면 재질문
```

**질문 2 - 커맨드 설명**

**A. Phase 0을 완료한 경우 (추천 모드)**:
```
질문: "다음은 대화 내용을 바탕으로 생성된 커맨드 설명입니다. 어떻게 하시겠습니까?"

자동 생성된 설명 제시: "{분석된_설명}"

선택지:
  - 그대로 사용
  - 수정하기

만약 "수정하기"를 선택하면:
  - 현재 설명을 기본값으로 제공
  - 사용자가 편집할 수 있도록 텍스트 입력 제공
```

**B. Phase 0을 건너뛴 경우 (직접 입력 모드)**:
```
질문: "커맨드에 대한 간단한 설명을 입력해주세요 (1-2문장)"
- 형식: 간결하고 명확한 설명
- 예: "프로젝트를 빌드하고 production 환경에 배포하는 워크플로우"
```

### Phase 2: 워크플로우 정의

**Phase 0 완료 여부에 따라 추천 모드 또는 직접 입력 모드로 진행합니다.**

**질문 3 - Triggers (트리거 조건)**

**A. Phase 0을 완료한 경우 (추천 모드)**:
```
질문: "대화에서 추출한 트리거 조건입니다. 확인하고 추가하시겠습니까?"

추출된 트리거 목록:
{자동_추출된_트리거_목록}

선택지:
  - 이대로 사용
  - 트리거 추가
  - 전체 수정

추가 입력이 필요한 경우:
  - 기존 트리거 유지하며 새 항목 추가
  - 여러 줄 입력 가능
```

**B. Phase 0을 건너뛴 경우 (직접 입력 모드)**:
```
질문: "커맨드가 자동으로 실행될 조건(트리거)을 입력해주세요"
- 형식: 목록 형태
- 예:
  - 배포 준비가 완료되었을 때
  - production 브랜치에 머지되었을 때
  - 릴리스 태그가 생성되었을 때
```

**질문 4 - Behavioral Flow (실행 단계)**

**A. Phase 0을 완료한 경우 (추천 모드)**:
```
질문: "대화에서 파악한 실행 단계입니다. 확인하고 수정하시겠습니까?"

추출된 실행 단계:
{자동_정리된_실행_단계}

선택지:
  - 그대로 사용
  - 단계 추가
  - 전체 수정

추가/수정 시:
  - 기존 단계를 편집 가능한 형태로 제공
  - 단계 번호와 설명 형식 안내
```

**B. Phase 0을 건너뛴 경우 (직접 입력 모드)**:
```
질문: "커맨드의 실행 단계를 입력해주세요"
- 형식:
  1. **단계명**: 단계 설명
  2. **단계명**: 단계 설명
- 예:
  1. **검증**: 배포 전 조건 확인 (테스트 통과, 브랜치 확인)
  2. **빌드**: 프로젝트 빌드 및 최적화
  3. **테스트**: 빌드된 결과물 검증
  4. **배포**: production 서버에 배포
```

**질문 5 - Boundaries (경계 정의)**

**A. Phase 0을 완료한 경우 (추천 모드)**:
```
질문: "대화에서 식별한 경계 조건입니다. 확인하고 추가하시겠습니까?"

Will (수행할 작업):
{자동_수집된_Will_목록}

Will Not (수행하지 않을 작업):
{자동_수집된_WillNot_목록}

선택지:
  - 그대로 사용
  - 항목 추가
  - 수정하기

추가 시:
  - 기존 항목 유지
  - 새 항목을 목록 형태로 입력
```

**B. Phase 0을 건너뛴 경우 (직접 입력 모드)**:
```
질문: "커맨드가 수행할 작업(Will)을 입력해주세요"
- 형식: 목록 형태
- 예:
  - 프로젝트를 빌드합니다
  - 테스트를 실행하고 결과를 확인합니다
  - production 서버에 배포합니다

질문: "커맨드가 수행하지 않을 작업(Will Not)을 입력해주세요"
- 형식: 목록 형태
- 예:
  - 테스트가 실패하면 배포하지 않습니다
  - 수동 승인 없이 자동 배포하지 않습니다
  - 롤백 작업은 수행하지 않습니다
```

### Phase 3: 도구 설정

**질문 6 - Tool Coordination (도구 사용)**

**A. Phase 0을 완료한 경우 (추천 모드)**:
```
질문: "대화에서 식별한 사용 도구입니다. 확인해주세요."

추출된 도구 목록:
{자동_식별된_도구_목록}

선택지:
  - 모두 포함
  - 선택적으로 포함
  - 도구 추가

도구 추가 시:
  - 도구 이름과 사용 목적 입력
```

**B. Phase 0을 건너뛴 경우 (직접 입력 모드)**:
```
질문: "커맨드에서 사용할 도구를 선택해주세요"
- 형식: 도구명: 사용 목적
- 예:
  - Bash: 빌드 스크립트 실행 및 배포 명령 수행
  - Read: 설정 파일 읽기 및 환경 변수 확인
  - Write: 배포 로그 작성
```

### Phase 4: 예제 및 문서화

**질문 7 - Usage (사용법)**

**A. Phase 0을 완료한 경우 (추천 모드)**:
```
질문: "대화를 바탕으로 사용법을 생성했습니다. 확인해주세요."

자동 생성된 사용법:
{생성된_사용법_예시}

선택지:
  - 그대로 사용
  - 수정하기
```

**B. Phase 0을 건너뛴 경우 (직접 입력 모드)**:
```
질문: "커맨드의 사용법을 입력해주세요"
- 형식:
  /{커맨드명} [arguments] [--flags]
- 예:
  /deploy-production --env=prod --confirm
```

**질문 8 - Examples (사용 예제)**

**A. Phase 0을 완료한 경우 (추천 모드)**:
```
질문: "대화에서 발견한 사용 예제입니다. 확인해주세요."

발견된 예제 개수: {예제_개수}개

각 예제에 대해:
  - 예제 제목: {자동_생성된_제목}
  - 사용법: {추출된_사용법}
  - 설명: {추출된_설명}

선택지:
  - 모두 포함
  - 선택적으로 포함
  - 예제 추가
  - 예제 제외
```

**B. Phase 0을 건너뛴 경우 (직접 입력 모드)**:
```
질문: "사용 예제를 추가하시겠습니까?"

선택지:
  - 예 (예제 작성)
  - 아니오 (기본 예제만 포함)

만약 "예"를 선택하면:
  예제 제목, 사용법, 설명 입력 요청
```

### Phase 5: 파일 생성

수집한 정보를 바탕으로 다음 파일 구조를 생성합니다:

```
plugins/command-creator/commands/{커맨드-이름}.md
```

**커맨드 파일 템플릿**:
```markdown
---
name: {커맨드-이름}
description: "{커맨드-설명}"
---

# /{커맨드-이름} - {영문-제목}

{선택적_컨텍스트_노트}

## Triggers
{트리거_조건_목록}

## Usage
\```
{사용법_예시}
\```

## Behavioral Flow
{실행_단계}

Key behaviors:
{핵심_동작_목록}

## Tool Coordination
{도구_사용_목록}

## Key Patterns
{핵심_패턴_목록}

## Examples

### {예제_제목_1}
\```
{예제_사용법_1}
\```
{예제_설명_1}

### {예제_제목_2}
\```
{예제_사용법_2}
\```
{예제_설명_2}

## Boundaries

**Will:**
{수행할_작업_목록}

**Will Not:**
{수행하지_않을_작업_목록}
```

### Phase 6: 검증 및 완료

1. **파일 생성 확인**
   - 디렉토리가 올바르게 생성되었는지 확인
   - 커맨드 파일이 존재하는지 확인

2. **내용 검증**
   - Frontmatter (---) 형식이 올바른지 확인
   - 모든 필수 섹션이 포함되어 있는지 확인
   - 마크다운 문법이 올바른지 확인

3. **사용자 안내**
   ```
   ✅ 커맨드가 성공적으로 생성되었습니다!

   📂 위치: plugins/command-creator/commands/{커맨드-이름}.md

   📖 다음 단계:
   1. .claude/commands/로 복사하여 사용
      cp plugins/command-creator/commands/{커맨드-이름}.md .claude/commands/

   2. 또는 심볼릭 링크 생성
      ln -s "$(pwd)/plugins/command-creator/commands/{커맨드-이름}.md" .claude/commands/{커맨드-이름}.md

   3. 커맨드 실행
      /{커맨드-이름}

   💡 팁:
   - 커맨드는 언제든지 수정 가능합니다
   - 네임스페이스를 사용하려면 파일명을 {네임스페이스}/{커맨드-이름}.md로 변경하세요
   - 다른 사람과 공유하여 팀의 워크플로우를 표준화하세요
   ```

## 성공 기준

- ✅ 현재 세션의 대화 내용을 분석하여 워크플로우 정보를 추출함
- ✅ 분석 결과를 바탕으로 커맨드 이름, 트리거, 실행 단계, 도구를 자동으로 추천함
- ✅ 추천된 내용을 사용자에게 선택지로 제시함
- ✅ 사용자가 추천 내용을 선택하거나 수정할 수 있음
- ✅ 입력된 정보가 유효성 검사를 통과함
- ✅ 표준 구조의 커맨드 `.md` 파일이 생성됨
- ✅ Frontmatter와 모든 필수 섹션이 포함됨
- ✅ 생성된 커맨드가 즉시 사용 가능함
- ✅ 사용자에게 명확한 다음 단계 안내가 제공됨

## 에러 처리

### 잘못된 커맨드 이름
```
❌ 입력된 이름이 올바른 형식이 아닙니다.
📝 커맨드 이름은 kebab-case 형식이어야 합니다.
   예: deploy-production, run-tests, code-review

재입력해주세요:
```

### 이미 존재하는 커맨드
```
⚠️ 같은 이름의 커맨드가 이미 존재합니다.
📂 위치: plugins/command-creator/commands/{커맨드-이름}.md

다음 중 선택해주세요:
1. 다른 이름 사용
2. 기존 커맨드 덮어쓰기 (기존 내용 손실)
3. 취소
```

### 필수 정보 누락
```
⚠️ 필수 정보가 입력되지 않았습니다.
📋 다음 정보를 입력해주세요: {누락된-필드}
```

## 주의사항

1. **진행 상황 추적**:
   - 각 Phase 시작 시 "✅ Phase X 완료 → 🔄 Phase Y 시작: [Phase 설명]" 형식으로 진행 상황 안내
   - 전체 프로세스 중 현재 위치를 명확히 표시: "📊 진행 상황: X/7 Phase 완료"
   - Phase 완료 시 체크리스트 업데이트 상태를 사용자에게 알림
   - 예시:
     ```
     ✅ Phase 1 완료 → 🔄 Phase 2 시작: 워크플로우 정의

     📊 진행 상황: 2/7 Phase 완료
     - ✅ Phase 0, 1 완료
     - 🔄 Phase 2 진행 중
     - ⏳ Phase 3, 4, 5, 6 대기 중
     ```

2. **Phase 0 조건부 실행**:
   - 먼저 대화 내용 충분성을 판단 (메시지 5개 이상, 워크플로우 내용 포함 여부)
   - 충분하지 않으면 Phase 0 건너뛰고 직접 입력 모드로 진행
   - 충분하면 대화 분석 후 추천 모드로 진행

2. **대화 분석 우선** (Phase 0 실행 시):
   - 질문하기 전에 반드시 현재 세션의 대화 내용을 분석하여 워크플로우 추출
   - 분석 결과가 없거나 부족하면 사용자에게 안내 후 직접 입력 모드로 전환

3. **모드별 질문 방식**:
   - **추천 모드**: 추출된 내용을 선택지로 제시하고 "직접 입력" 옵션 포함
   - **직접 입력 모드**: 예시와 함께 사용자에게 직접 입력 요청

4. **AskUserQuestion 사용**: 모든 정보 수집은 AskUserQuestion 도구를 통해 단계별로 진행

5. **Write 도구 사용**: 커맨드 파일 생성 시 Write 도구 사용

6. **Bash 도구 사용**: 디렉토리 생성 시 `mkdir -p` 명령 사용

7. **검증 필수**: 파일 생성 후 반드시 내용 검증

8. **친절한 피드백**: 각 단계마다 사용자에게 진행 상황 안내

9. **분석 결과 공유**: Phase 0 완료 시 발견된 워크플로우를 요약하여 사용자에게 제시

10. **Frontmatter 정확성**: name과 description 필드가 올바르게 설정되었는지 확인

## 대화 분석 가이드라인

### 효과적인 분석을 위한 체크리스트

- ✅ **워크플로우 식별**: 대화에서 논의된 작업 흐름과 자동화 프로세스 찾기
- ✅ **트리거 추출**: "~할 때", "~하면" 등의 조건문 수집
- ✅ **단계 파악**: 순서대로 수행되는 작업들 식별
- ✅ **도구 수집**: Bash 명령, 파일 작업 등 사용 도구 파악
- ✅ **경계 식별**: "해야 한다", "하면 안 된다" 등의 제약 조건 찾기
- ✅ **실행 맥락 이해**: 언제, 왜 이 워크플로우가 필요한지 파악

### 추천 생성 전략

**커맨드 이름 생성**:
- 워크플로우의 주요 작업을 2-4개 단어로 요약
- kebab-case 형식 준수
- 동사-명사 조합 선호 (예: deploy-production, run-tests)

**설명 생성**:
- 1-2문장으로 워크플로우의 목적과 결과 명확히
- "~을 ~하는" 형식 사용
- 구체적인 작업과 목표 명시

**워크플로우 구조화**:
- 대화에서 논의된 단계를 논리적 순서로 재구성
- 각 단계의 입력/출력 명확히
- 의존성과 조건 파악

---

**이제 커맨드 생성을 시작합니다. 먼저 현재 세션의 대화를 분석하고, 워크플로우 정보를 추출한 후, 사용자와 대화하며 커맨드를 완성합니다.**
